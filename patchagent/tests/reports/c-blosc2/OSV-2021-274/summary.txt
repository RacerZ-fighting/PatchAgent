The sanitizer detected a memcpy param overlap vulnerability. The explanation of the vulnerability is: The source and destination buffers of a memory copy operation overlap, causing data corruption. Here is the detail: 

    - __asan_memcpy /src/llvm-project/compiler-rt/lib/asan/asan_interceptors_memintrinsics.cpp:63:3
    - frame_get_metalayers /src/c-blosc2/blosc/frame.c:1263:5
    - blosc2_frame_to_schunk /src/c-blosc2/blosc/frame.c:1452:8
    - blosc2_schunk_open_sframe /src/c-blosc2/blosc/schunk.c:290:27
    - LLVMFuzzerTestOneInput /src/c-blosc2/tests/fuzz/fuzz_decompress_frame.c:23:27
    - fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerLoop.cpp:614:13
    - fuzzer::RunOneTest(fuzzer::Fuzzer*, char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:327:6
    - fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:862:9
    - main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10

Address 0x000000000000 is a wild pointer inside of access range of size 0xffffffffff20ffff.
0x50d000000115 is located 5 bytes inside of 134-byte region [0x50d000000110,0x50d000000196)
allocated by thread T0 here:
    - malloc /src/llvm-project/compiler-rt/lib/asan/asan_malloc_linux.cpp:68:3
    - fuzzer::RunOneTest(fuzzer::Fuzzer*, char const*, unsigned long) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:327:6
    - fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerDriver.cpp:862:9
    - main /src/llvm-project/compiler-rt/lib/fuzzer/FuzzerMain.cpp:20:10


To fix this issue, follow the advice below:

1. Ensure that the source and destination buffers do not overlap in memcpy operations.
2. If overlapping memory regions must be copied, use memmove instead of memcpy.
3. Validate memory regions before performing copy operations.